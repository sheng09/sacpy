#include "crossterm.hh"
#include "sensitivity.hh"
#include "getopt/getopt.hpp"
#include "hdf5_hl.h"
#include <iostream>
#include <unordered_set>
#include <unordered_map>
#define NCLINE 8192

static char HMSG[] = "\
Compute the sensitivities of body-wave cross-terms.\n\
\n\
%s --cc=fnm  --sens=fnm  -O=fnm  [-V]\n\
\n\
Args:\n\
    --cc=fnm   : the file that declares body wave cross-terms.\n\
        Each line is `cc_id(int)  body_wave_id1(int)  body_wave_id2(int)  tag(string without whitespace)`.\n\
        Lines start with `#` are comments.\n\
    --sens=fnm : the sensitivity file generated by fw_traveltime_sensitivity.x.\n\
    -O=fnm     : the filename for output cross-term sensitivties.\n\
    -V         : turn on verbose.\n\
\n\
";

int main(int ac, char *av[] )
{
    char msg[MAXMSG_LEN];
    if (ac <= 1)
    {
        fprintf(stdout, HMSG, av[0]);
        return 0;
    }
    std::string cc_fnm = getarg("", "--cc");
    std::string sen_fnm = getarg("", "--sens");
    std::string out_fnm = getarg("", "-O");
    bool verbose = getarg(false, "-V", "--verbose");
    if (cc_fnm.empty() || sen_fnm.empty() || out_fnm.empty() )
    {
        fprintf(stderr, "Err. Check args.\n");
        exit(-1);
    }
    /////// Read cc pairs.
    std::unordered_set<int> body_wave_id_set;
    std::vector<crossterm> ccs;
    FILE *fid = fopen(cc_fnm.c_str(), "r");
    char line[NCLINE];
    char tag[NCLINE];
    for(;;)
    {
        std::memset(line, 0, NCLINE);
        if (fgets(line, NCLINE, fid) == NULL) break;
        if (line[0] == '#') continue;
        //
        std::memset(tag, 0, NCLINE);
        int cc_id, id1, id2;
        sscanf(line, "%d %d %d %s", &cc_id, &id1, &id2, tag);
        ccs.push_back( crossterm(cc_id, id1, id2, tag) );

        body_wave_id_set.insert(id1);
        body_wave_id_set.insert(id2);
    }
    fclose(fid);
    if (verbose)
    {
        std::memset(msg, 0, MAXMSG_LEN);
        sprintf(msg, "Init cross-terms from `%s`. Number: (%ld)\n",  cc_fnm.c_str(), ccs.size() );
        verbose_print(0, msg);
    }

    //////// input body wave sensitivities
    if (verbose)
    {
        std::memset(msg, 0, MAXMSG_LEN);
        sprintf(msg, "Reading seismic-wave sensitivties (%ld) from `%s`...\n", body_wave_id_set.size(),  sen_fnm.c_str() );
        verbose_print(0, msg);
    }

    int nray;
    hid_t fin = H5Fopen(sen_fnm.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT );
    hid_t grp_sens = H5Gopen2(fin, "sensitivity_zip", H5P_DEFAULT);
    H5LTget_attribute_int(grp_sens, ".", "size", &nray);
    //std::vector<sensitivity_zip> body_wave_sens(nray);
    std::unordered_map<int, sensitivity_zip> map_body_wave_sens;
    std::vector<int>    index_p, index_s;
    std::vector<double> value_p, value_s;
    std::vector<double> value_p_raylength, value_s_raylength;
    for(int idx=0; idx<nray; ++idx)
    {
        // if (verbose)
        // {
        //     std::memset(msg, 0, MAXMSG_LEN);
        //     sprintf(msg, "[%d/%d]\n", idx+1, nray );
        //     verbose_print(1, msg);
        // }
        static char sub_grp_name[NCLINE];
        std::memset(sub_grp_name, 0, NCLINE);
        ssize_t junk = H5Lget_name_by_idx (grp_sens, ".", H5_INDEX_NAME, H5_ITER_INC, idx, sub_grp_name, 4096, H5P_DEFAULT);
        int id;
        
        H5LTget_attribute_int(grp_sens, sub_grp_name, "id",    &id);
        if (body_wave_id_set.find(id) == body_wave_id_set.end() ) { continue; }

        int sizep=0;
        int sizes=0;
        static char c_phase[NCLINE], c_tag[NCLINE];
        std::memset(c_phase, 0, NCLINE);
        std::memset(c_tag, 0, NCLINE);
        double t1d_taup, t1d, t3d;
        H5LTget_attribute_int(grp_sens, sub_grp_name, "sizep", &sizep);
        H5LTget_attribute_int(grp_sens, sub_grp_name, "sizes", &sizes);
        H5LTget_attribute_string(grp_sens, sub_grp_name, "phase", c_phase );
        H5LTget_attribute_double(grp_sens, sub_grp_name, "time1d_taup", &t1d_taup);
        H5LTget_attribute_double(grp_sens, sub_grp_name, "time1d", &t1d);
        H5LTget_attribute_double(grp_sens, sub_grp_name, "time3d", &t3d);
        H5LTget_attribute_string(grp_sens, sub_grp_name, "tag", c_tag );

        
        index_p.resize(sizep);
        value_p.resize(sizep);
        value_p_raylength.resize(sizep);
        index_s.resize(sizes);
        value_s.resize(sizes);
        value_s_raylength.resize(sizes);

        std::string loc(sub_grp_name);
        std::string loc_ip = loc+"/index_P";
        std::string loc_is = loc+"/index_S";
        std::string loc_vp = loc+"/value_P";
        std::string loc_vs = loc+"/value_S";
        std::string loc_vp_raylength = loc+"/value_P_raylegnth";
        std::string loc_vs_raylength = loc+"/value_S_raylegnth";


        H5LTread_dataset_int(   grp_sens, loc_ip.c_str(), index_p.data() );
        H5LTread_dataset_int(   grp_sens, loc_is.c_str(), index_s.data() );
        H5LTread_dataset_double(grp_sens, loc_vp.c_str(), value_p.data() );
        H5LTread_dataset_double(grp_sens, loc_vs.c_str(), value_s.data() );
        H5LTread_dataset_double(grp_sens, loc_vp_raylength.c_str(), value_p_raylength.data() );
        H5LTread_dataset_double(grp_sens, loc_vs_raylength.c_str(), value_s_raylength.data() );

        //body_wave_sens[idx].set(sizep, index_p.data(), value_p.data(), sizes, index_s.data(), value_s.data() );
        //map_body_wave_sens[id] = &(body_wave_sens[idx]);
        map_body_wave_sens[id] = sensitivity_zip(sizep, index_p.data(), value_p.data(), value_p_raylength.data(),
                                                 sizes, index_s.data(), value_s.data(), value_s_raylength.data() );
        map_body_wave_sens[id].set_id(id);
        map_body_wave_sens[id].set_phase(c_phase);
        map_body_wave_sens[id].set_time_1d_taup(t1d_taup);
        map_body_wave_sens[id].set_time_1d(t1d);
        map_body_wave_sens[id].set_time_3d(t3d);
        map_body_wave_sens[id].set_tag(c_tag);
    }
    if( !body_wave_id_set.empty() ) body_wave_id_set.clear();
    if( !index_p.empty() ) index_p.clear();
    if( !index_s.empty() ) index_s.clear();
    if( !value_p.empty() ) value_p.clear();
    if( !value_s.empty() ) value_s.clear();
    H5Gclose(grp_sens);
    H5Fclose(fin);

    //////// output sensitivities
    hid_t fout = H5Fcreate(out_fnm.c_str(), H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    hid_t grp_out = H5Gcreate2(fout, "sensitivity_zip", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    ///
    cc_sensitivity_zip  sen_diff;
    if (verbose)
    {
        verbose_print(0, "Computing cross-term sensitivties...\n");
    }
    int idx = 0;
    for(auto it_cc = ccs.begin(); it_cc != ccs.end(); ++it_cc)
    {
        int ccid = it_cc->ccid();
        int id1  = it_cc->id1();
        int id2  = it_cc->id2();
        std::string &tag = it_cc->tag();
        auto sen1 = map_body_wave_sens.find(id1);
        auto sen2 = map_body_wave_sens.find(id2);
        if (sen1 == map_body_wave_sens.end() || sen2 == map_body_wave_sens.end() )
        {
            fprintf(stderr, "Err. Cannot find body wave sensitivities for the cross-term (%d)(%d-%d)\n", ccid, id1, id2);
            exit(-1);
        }
        // compute cross-term sensitivity
        sen_diff.run_crossterm(sen1->second, sen2->second );
        double dt_1d_taup = sen_diff.time_1d_taup();
        double dt_1d = sen_diff.time_1d();
        double dt_3d = sen_diff.time_3d();
        // output
        static char sub_grp_name[NCLINE];
        std::memset(sub_grp_name, 0, NCLINE);
        sprintf(sub_grp_name, "%d", ccid);
        hid_t single_sens = H5Gcreate2(grp_out, sub_grp_name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
        H5LTset_attribute_int(single_sens, ".", "ccid", &ccid, 1);
        H5LTset_attribute_int(single_sens, ".", "id1",  &id1, 1);
        H5LTset_attribute_int(single_sens, ".", "id2",  &id2, 1);
        H5LTset_attribute_double(single_sens, ".", "time1d_taup", &dt_1d_taup, 1);
        H5LTset_attribute_double(single_sens, ".", "time1d", &dt_1d, 1);
        H5LTset_attribute_double(single_sens, ".", "time3d", &dt_3d, 1);
        H5LTset_attribute_string(single_sens, ".", "phase1", sen_diff.phase1().c_str() );
        H5LTset_attribute_string(single_sens, ".", "phase2", sen_diff.phase2().c_str() );
        H5LTset_attribute_string(single_sens, ".", "tag1", sen1->second.tag().c_str() );
        H5LTset_attribute_string(single_sens, ".", "tag2", sen2->second.tag().c_str() );
        H5LTset_attribute_string(single_sens, ".", "tag", tag.c_str() );

        int size;
        hsize_t dim[1];
        std::vector<int> row_index;
        std::vector<double> row_value;
        std::vector<double> row_value_raylength;

        sen_diff.obtain_sensitivity(row_index, row_value, row_value_raylength, 'P');
        size = row_index.size();
        dim[0] = size;
        H5LTset_attribute_int(single_sens, ".", "sizep", &size, 1);
        H5LTmake_dataset_int(single_sens,    "index_P", 1, dim, row_index.data() );
        H5LTmake_dataset_double(single_sens, "value_P", 1, dim, row_value.data() );
        H5LTmake_dataset_double(single_sens, "value_P_raylegnth", 1, dim, row_value_raylength.data() );

        sen_diff.obtain_sensitivity(row_index, row_value, row_value_raylength, 'S');
        size = row_index.size();
        dim[0] = size;
        H5LTset_attribute_int(single_sens, ".", "sizes", &size, 1);
        H5LTmake_dataset_int(single_sens,    "index_S", 1, dim, row_index.data() );
        H5LTmake_dataset_double(single_sens, "value_S", 1, dim, row_value.data() );
        H5LTmake_dataset_double(single_sens, "value_S_raylegnth", 1, dim, row_value_raylength.data() );
        // 
        if (!row_index.empty() ) row_index.clear();
        if (!row_value.empty() ) row_value.clear();
        //
        H5Gclose(single_sens);
        if (verbose)
        {
            std::memset(msg, 0, MAXMSG_LEN);
            sprintf(msg, "[%d/%ld] (%d:%d-%d) (%s). time1d(%lf) time1d_taup(%lf) time3d(%lf)\n", ++idx, ccs.size(), ccid, id1, id2, 
                    tag.c_str(),
                    dt_1d, dt_1d_taup, dt_3d);
            verbose_print(1, msg);
        }
    }
    
    if( !map_body_wave_sens.empty() ) map_body_wave_sens.clear();
    if( !ccs.empty() ) ccs.clear();
    H5Gclose(grp_out);
    H5Fclose(fout);
    //
    if (verbose)
    {
        verbose_print(0, "Safely exit.\n");
    }
    return 0;
}