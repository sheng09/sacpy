#include "sensitivity.hh"
#include "getopt/getopt.hpp"
#include "hdf5_hl.h"
#include <iostream>

static char HMSG[] = "\
Compute traveltime sensitivity given a background model.\n\
\n\
%s --model3d=p/fnm --raypath=fnm --output_sensitivity=fnm.bin   [--zip]\n\
    --output_raypath_segments=fnm.txt --verbose=0\n\
\n\
Arg details:\n\
    --model3d= : `p/fnm` to init the 3-D model from an external file.\n\
                 Use `p` for plain-text file, and `b` for binary file.\n\
                 The external file is in the same format as that generated by\n\
                 `fw_generate_mode3d.x`.\n\
        Do not use this arg so that the 1-D ak135 model is used to init the 3-D model.\n\
\n\
    --raypath= : `fnm` is a hdf5 file that declare many raypaths.\n\
                 The file is generated by `raypath.py`.\n\
\n\
    [--zip] :\n\
    --output_sensitivity=fnm.bin : the binary file to output the sensitivity.\n\
            There are two output formats.\n\
            1) whole sensitivity values:\n\
                t0(float64) npts(int32) s1 (float64) s2 ... sN \n\
            2) zipped non-zero sensitivity values:\n\
                t0(float64) npts(int32) idx1(int32) idx2 ... idxM v1(float64) v2 ... vM\n\
\n\
    --output_raypath_segments= : use this arg to output raypath segments according to phase name.\n\
";
int main(int argc, char *argv[])
{
    static char verbose_msg[MAXMSG_LEN];
    if (argc == 1)
    {
        fprintf(stdout, HMSG, argv[0]);
        return 0;
    }
    //
    bool verbose = getarg(false, "--verbose");
    // set 3-D model
    std::string model_setting = getarg("", "--model3d");
    earthmod3d * mod3d;
    if (model_setting.empty() ) 
    {
        int ndep = ak135::dep_grd_size;
        double *dep = ak135::dep_grd;
        double dlon=2.0;
        double dlat=2.0;
        if (verbose)
        {
            std::memset(verbose_msg, 0, MAXMSG_LEN);
            sprintf(verbose_msg, "Init 3-D model from internal ak135. dlon: %lf, dlat: %lf\n", dlon, dlat);
            verbose_print(0, verbose_msg);
        }
        mod3d = new earthmod3d(&ak135::model, dlon, dlat, dep, ndep);
    }
    else
    {
        const char mode = model_setting[0];
        const char *fnm = model_setting.c_str()+2;
        if (verbose)
        {
            std::memset(verbose_msg, 0, MAXMSG_LEN);
            sprintf(verbose_msg, "Init 3-D model from external file. (%s)\n", fnm);
            verbose_print(0, verbose_msg);
        }
        mod3d = new earthmod3d(&ak135::model, fnm, mode);
    }
    // set ray-path file
    std::string ray_fnm = getarg("", "--raypath");
    if (ray_fnm.empty() )
    {
        fprintf(stderr, "Err. please provide raypath file.\n");
        exit(-1);
    }
    std::string output_raypath_segments = getarg("", "--output_raypath_segments");
    if (output_raypath_segments.empty() )
    {
        fprintf(stderr, "Err. please provide output_raypath_segments file.\n");
        exit(-1);
    }
    if (verbose)
    {
        std::memset(verbose_msg, 0, MAXMSG_LEN);
        sprintf(verbose_msg, "Set input raypth file (%s) and output sensitivity file (%s)\n",  ray_fnm.c_str(), output_raypath_segments.c_str() );
        verbose_print(0, verbose_msg);
    }
    // input HDF5
    int nray;
    hid_t fid = H5Fopen(ray_fnm.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
    hid_t  grp_raypath = H5Gopen2(fid, "raypath", H5P_DEFAULT);
    H5LTget_attribute_int(grp_raypath, ".", "size", &nray);
    // output HDF5
    hid_t out_fid  = H5Fcreate(output_raypath_segments.c_str(), H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
    hid_t grp_sens = H5Gcreate2(out_fid, "sensitivity_zip", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
    H5LTset_attribute_int(grp_sens, ".", "size", &nray, 1);
    H5LTset_attribute_string(grp_sens, ".", "info", "The sensitivity is based on 1D earth model");
    // Loop over all raypath
    raypath3d   ray;
    sensitivity_zip gmat;
    if (verbose)
    {
        verbose_print(0, "Start running for each raypath...\n");
    }
    std::vector<double> lons, lats, deps;
    for (int idx=0; idx<nray; ++idx)
    {
        static char sub_grp_name[4096];
        std::memset(sub_grp_name, 0, 4096);
        ssize_t junk = H5Lget_name_by_idx (grp_raypath, ".", H5_INDEX_NAME, H5_ITER_INC, idx, sub_grp_name, 4096, H5P_DEFAULT);
        
        int npts;
        int id;
        double rp, time;
        static char c_phase[4096], c_tag[4096];
        std::memset(c_phase, 0, 4096);
        std::memset(c_tag, 0, 4096);

        H5LTget_attribute_int(grp_raypath,    sub_grp_name, "id", &id);
        H5LTget_attribute_int(grp_raypath,    sub_grp_name, "npts", &npts);
        H5LTget_attribute_double(grp_raypath, sub_grp_name, "ray_param", &rp);
        H5LTget_attribute_double(grp_raypath, sub_grp_name, "time", &time);
        H5LTget_attribute_string(grp_raypath, sub_grp_name, "phase", c_phase);
        H5LTget_attribute_string(grp_raypath, sub_grp_name, "tag", c_tag);
        std::string phase(c_phase);
        std::string tag(c_tag);

        if (verbose)
        {
            std::memset(verbose_msg, 0, MAXMSG_LEN);
            sprintf(verbose_msg, "[%d/%d] running... raypath id(%d) tag(%s) npts(%d)\n", idx+1, nray, id, c_tag, npts );
            verbose_print(1, verbose_msg);
        }

        lons.resize(npts);
        lats.resize(npts);
        deps.resize(npts);
        std::string loc(sub_grp_name);
        std::string loclon = loc+"/lon";
        std::string loclat = loc+"/lat";  
        std::string locdep = loc+"/depth";
        H5LTread_dataset_double(grp_raypath,  loclon.c_str(), lons.data() );
        H5LTread_dataset_double(grp_raypath,  loclat.c_str(), lats.data() );
        H5LTread_dataset_double(grp_raypath,  locdep.c_str(), deps.data() );

        // check ray-path
        // int test_idx = 900;
        // fprintf(stdout, "    %d: %.12lf %.12lf %.12lf\n", test_idx, lons[test_idx], lats[test_idx], deps[test_idx] );
        ray.init(c_phase, npts, lons.data(), lats.data(), deps.data(), time, rp, c_tag, 2);

        if (verbose)
        {
            verbose_print(2, "Computing sensitivities...\n");
        }
        gmat.clear();
        gmat.run(*mod3d, ray, 3);
        double t  = gmat.time_1d();
        double t0 = ray.traveltime_taup();
        double t3d =gmat.time_3d();
        if (verbose)
        {    
            double relative_err = fabs((t0-t)/t)*100;
            double dt = t3d-t;

            std::memset(verbose_msg, 0, MAXMSG_LEN);
            sprintf(verbose_msg, "time: 1D_here(%lf) 1Dtaup(%lf), err: %lf%%. 3Dhere(%lf, %lf) \n", t, t0, relative_err, t3d, dt);
            verbose_print(2, verbose_msg);
        }
        
        // set sensitivity
        hid_t single_sens = H5Gcreate2(grp_sens, sub_grp_name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
        H5LTset_attribute_int(single_sens, ".", "id", &id, 1);
        H5LTset_attribute_double(single_sens, ".", "ray_param", &rp, 1);
        H5LTset_attribute_string(single_sens, ".", "phase", c_phase);
        H5LTset_attribute_string(single_sens, ".", "tag",   c_tag);

        H5LTset_attribute_double(single_sens, ".", "time1d", &t, 1);
        H5LTset_attribute_double(single_sens, ".", "time1d_taup", &t0, 1);
        H5LTset_attribute_double(single_sens, ".", "time3d", &t3d, 1);
        std::vector<int> row_index;
        std::vector<double> row_value;

        gmat.obtain_sensitivity(row_index, row_value, 'P');
        int size = row_index.size();
        hsize_t dim[1];
        dim[0] = size;
        H5LTset_attribute_int(single_sens, ".", "sizep", &size, 1);
        H5LTmake_dataset_int(single_sens,    "index_P", 1, dim, row_index.data() );
        H5LTmake_dataset_double(single_sens, "value_P", 1, dim, row_value.data() );

        gmat.obtain_sensitivity(row_index, row_value, 'S');
        size = row_index.size();
        dim[0] = size;
        H5LTset_attribute_int(single_sens, ".", "sizes", &size, 1);
        H5LTmake_dataset_int(single_sens,    "index_S", 1, dim, row_index.data() );
        H5LTmake_dataset_double(single_sens, "value_S", 1, dim, row_value.data() );
        
        if (!row_index.empty() ) row_index.clear();
        if (!row_value.empty() ) row_value.clear();

        H5Gclose(single_sens);
    }
    if( !lons.empty() ) lons.clear();
    if( !lats.empty() ) lats.clear();
    if( !deps.empty() ) deps.clear();
    H5Gclose(grp_raypath);
    H5Fclose(fid);
    H5Gclose(grp_sens);
    H5Fclose(out_fid);
    //
    verbose_print(0, "Safely exit\n");

    delete mod3d;
    return 0;
}
